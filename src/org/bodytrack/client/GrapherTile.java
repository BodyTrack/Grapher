package org.bodytrack.client;

import java.util.ArrayList;
import java.util.List;

import com.google.gwt.core.client.JavaScriptObject;
import com.google.gwt.core.client.JsArray;
import com.google.gwt.core.client.JsArrayNumber;
import com.google.gwt.core.client.JsArrayString;
import com.google.gwt.http.client.Request;
import com.google.gwt.http.client.RequestBuilder;
import com.google.gwt.http.client.RequestCallback;
import com.google.gwt.http.client.RequestException;
import com.google.gwt.http.client.Response;

/**
 * Represents a single tile of data.
 *
 * <p>An overlay type for a generic data tile.  This data type can be loaded
 * from JSON using the {@link #buildTile(String)} method.</p>
 *
 * <p>Note that this class is final because GWT requires that all method
 * calls on an overlay type be resolved at compile time.  We had the choice
 * between making the class final and making all public instance methods
 * final.  We opted for the former option.</p>
 */
// TODO: See if using JSONParser.parseStrict() is better than eval()
// (it is definitely safer)
// TODO: Perhaps change this from an overlay type to something that
// holds a reference to a JSONValue, which would allow arrays and objects
// without the fix implemented in retrieveTile.  This would also allow
// using JSONParser.parseStrict() for safety.

// Note: it is possible to cast back and forth between JavaScriptObject
// and an overlay type, and the casts will succeed.
public final class GrapherTile extends JavaScriptObject {
	/**
	 * The width of a tile, in data points.
	 *
	 * <p>Each tile is defined to encompass all data in a time range
	 * equal to {@code Math.pow(2, level) * TILE_WIDTH} seconds.</p>
	 */
	public static final int TILE_WIDTH = 512;

	// Overlay types always have protected, zero-arg constructors
	// with empty bodies
	protected GrapherTile() { }

	/**
	 * Returns a single GrapherTile, given a JSON string containing the data.
	 *
	 * <h2 style="color: red">WARNING:</h2>
	 *
	 * <p>Note that the JSON string is assumed to be trusted.  This method uses
	 * the JavaScript eval() function, <strong>which could allow arbitrary
	 * code to execute on a user's browser</strong> if this string was not
	 * completely generated by BodyTrack servers over a secure connection.
	 * This could allow an attacker to view all of a user's data, simply by
	 * filling in code to request all valid data tiles and then to send
	 * those tiles to the attacker's machine.  As such, data from insecure
	 * connections, and especially from cross-site requests, should not be
	 * passed in as the data parameter here.</p>
	 *
	 * @param json
	 * 		a JSON string containing data for a single tile
	 * @return
	 * 		a GrapherTile object with the same data as is found in json
	 */
	public static native GrapherTile buildTile(String json) /*-{
		eval("var tile = " + json);
		return tile;
	}-*/;
	
	/**
	 * Retrieves a tile from the specified URL.
	 *
	 * <p>Adds a tile retrieved from url into destination whenever that tile
	 * arrives.  Since GWT only supports asynchronous server requests, there
	 * is no clean way to make this method block until the object comes in.
	 * Thus, this method takes a {@link java.util.List List}, into which
	 * the GrapherTile is placed when received.</p>
	 *
	 * <h2 style="color: red">WARNING:</h2>
	 *
	 * <p>Note that the URL is assumed to be trusted.  This method uses
	 * the JavaScript eval() function, <strong>which could allow arbitrary
	 * code to execute on a user's browser</strong> if this URL is not to
	 * a BodyTrack site over a secure connection.  This could allow an
	 * attacker to view all of a user's data, simply by filling in code
	 * to request all valid data tiles and then to send those tiles
	 * to the attacker's machine.  As such, URLs for insecure connections,
	 * and especially for other websites, should not be passed in as
	 * the data parameter here.</p>
	 *
	 * @param url
	 * 		the URL from which to retrieve the data
	 * @param destination
	 * 		the {@link java.util.List List} into which this method
	 * 		will add the tile when the tile is loaded from the server
	 * @param callback
	 * 		an {@link org.bodytrack.client.Alertable<String>} that
	 * 		is notified whenever the tile arrives, using a message
	 * 		of the url parameter.  This url parameter is helpful
	 * 		in notifications because it allows callback to
	 * 		differentiate between several requested tiles.
	 */
	public static void retrieveTile(String url,
			final List<GrapherTile> destination,
			Alertable<String> callback) {
		// Send request to server and catch any errors.
		RequestBuilder builder =
			new RequestBuilder(RequestBuilder.GET, url);

		try {
			// Required because an inner class can only access
			// a local variable if that variable is final
			final Alertable<String> callbackFinal = callback;
			final String urlFinal = url;

			builder.sendRequest(null, new RequestCallback() {
				@Override
				public void onError(Request request,
						Throwable exception) {
					callbackFinal.onFailure(urlFinal);
				}

				@Override
				public void onResponseReceived(Request request,
						Response response) {
					if (response.getStatusCode() == 200) {
						callbackFinal.onSuccess(urlFinal);

						String responseText = response.getText();
						if (isArray(responseText))
							// FIXME: This is a somewhat ugly response
							// This way we still get a JSON dictionary,
							// since a GrapherTile is an overlay type
							// over a JSONObject
							destination.add(buildTile(
								"{\"photo_descriptions\":"
								+ responseText
								+ ", \"contains_photo_descriptions\":true}"));
						else
							destination.add(buildTile(response.getText()));
					} else
						callbackFinal.onFailure(urlFinal);
				}

				/**
				 * Tells if the specified text refers to a JavaScript
				 * Array object rather than to a dictionary.
				 *
				 * @param json
				 * 		the JSON string to parse
				 * @return
				 * 		<tt>true</tt> if json represents a JavaScript
				 * 		Array value, not a dictionary
				 */
				private boolean isArray(String json) {
					// TODO: This only works in GWT 2.1 and later:
					// JSONValue parsed = JSONParser.parseStrict(json);

					// This is a hack until GWT 2.1
					int bracketIndex = json.indexOf('[');
					int curlyBracketIndex = json.indexOf('{');

					// An object is an array if the bracketed portion
					// surrounds the first set of curly braces
					return bracketIndex >= 0
						&& bracketIndex < curlyBracketIndex;
				}
			});
		} catch (RequestException e) {
			callback.onFailure(url);
		}
	}

	/**
	 * Returns the level of resolution at which this tile operates.
	 *
	 * <p>Note that level 0 corresponds to data points 1 second apart,
	 * and that levels scale in powers of 2.  For instance, level 1
	 * corresponds to data points 2 seconds apart, level 2 corresponds
	 * to data points 4 seconds apart, etc.  Levels can be positive or
	 * negative.</p>
	 *
	 * @return
	 * 		the level of resolution at which this tile operates
	 */
	public native int getLevel() /*-{
		return this.level;
	}-*/;

	/**
	 * Returns the offset from the epoch at which this tile is found.
	 *
	 * <p>If we consider a very larger array of tiles, each one at the same
	 * level as this one, and tile 0 beginning on midnight of 1/1/1970,
	 * the offset is the index in this array at which we can find this
	 * tile.</p>
	 *
	 * @return
	 * 		the offset value for this tile
	 */
	public native int getOffset() /*-{
		return this.offset;
	}-*/;

	/**
	 * Returns the list of field names for this tile.
	 *
	 * @return
	 * 		the list of field names for this tile
	 */
	public native JsArrayString getFields() /*-{
		return this.fields;
	}-*/;

	/**
	 * Returns the data stored in this tile.
	 *
	 * @return
	 * 		the data stored in this tile, as a two-dimensional array of
	 * 		double-precision values
	 */
	public native JsArray<JsArrayNumber> getData() /*-{
		return this.data;
	}-*/;

	/**
	 * Returns the value of the optional sample_width parameter in a tile.
	 *
	 * <p>Currently, this is a field only used by the Zeo data.</p>
	 *
	 * @return
	 * 		the value of the sample_width field for this tile, or a
	 * 		negative number if such a field is not present
	 */
	public native double getSampleWidth() /*-{
		if (! this.sample_width)
			return -1.0;

		return this.sample_width;
	}-*/;

	/**
	 * Tells whether this tile represents photo descriptions or not.
	 *
	 * @return
	 * 		<tt>true</tt> if and only if the contains_photo_descriptions
	 * 		field of this is <tt>true</tt>
	 */
	public native boolean containsPhotoDescriptions() /*-{
		// Can't return true if this.contains_photo_descriptions equal to
		// undefined (no such key) or false (explicitly marked false)
		return !! this.contains_photo_descriptions;
	}-*/;

	/**
	 * Returns a list of the
	 * {@link org.bodytrack.client.PhotoDescription PhotoDescription}
	 * objects that this GrapherTile holds.
	 *
	 * <p>This only works if {@link #containsPhotoDescriptions()}
	 * returns <tt>true</tt>, indicating that this data is available.</p>
	 *
	 * @return
	 * 		a list of <tt>PhotoDescription</tt> objects if available,
	 * 		<tt>null</tt> otherwise
	 */
	private native JsArray<JavaScriptObject> getRawDescriptions() /*-{
		if (! this.photo_descriptions)
			return null;

		return this.photo_descriptions;
	}-*/;

	/**
	 * Returns the data points that should be graphed for this GrapherTile.
	 *
	 * <p>Note that this works if and only if this GrapherTile represents
	 * a series of data points, not a photo description.</p>
	 *
	 * @return
	 * 		a {@link java.util.List List} of
	 * 		{@link org.bodytrack.client.PlottablePoint PlottablePoint}
	 * 		objects that represent the data in this GrapherTile, or
	 * 		<tt>null</tt> if the required data does not seem to be
	 * 		available (i.e. the field names &quot;time&quot; and
	 * 		&quot;mean&quot; are not elements of the array returned
	 * 		by {@link #getFields() getFields()}).  Also returns <tt>null</tt>
	 * 		if this GrapherTile represents a list of
	 * 		{@link org.bodytrack.client.PhotoDescription PhotoDescription}
	 * 		objects rather than a series of direct data points.
	 */
	public List<PlottablePoint> getDataPoints() {
		if (containsPhotoDescriptions())
			return null;

		int timeIndex = -1;
		int meanIndex = -1;

		JsArrayString fieldNames = getFields();

		for (int i = 0; i < fieldNames.length(); i++) {
			if (fieldNames.get(i).equalsIgnoreCase("time"))
				timeIndex = i;
			else if (fieldNames.get(i).equalsIgnoreCase("mean"))
				meanIndex = i;
		}

		if (timeIndex < 0 || meanIndex < 0)
			return null;

		List<PlottablePoint> result = new ArrayList<PlottablePoint>();
		JsArray<JsArrayNumber> dataPoints = getData();

		for (int i = 0; i < dataPoints.length(); i++) {
			JsArrayNumber dataPoint = dataPoints.get(i);

			double time = dataPoint.get(timeIndex);
			double mean = dataPoint.get(meanIndex);

			result.add(new PlottablePoint(time, mean));
		}

		return result;
	}

	/**
	 * Returns a list of available PhotoDescription objects if
	 * this tile contains photo descriptions, or <tt>null</tt>
	 * otherwise.
	 *
	 * @return
	 * 		a (possibly empty) List of PhotoDescriptions if
	 * 		{@link #containsPhotoDescriptions()} returns
	 * 		<tt>true</tt>, <tt>null</tt> otherwise
	 */
	public List<PhotoDescription> getPhotoDescriptions() {
		if (! containsPhotoDescriptions())
			return null;

		JsArray<JavaScriptObject> descriptions = getRawDescriptions();
		if (descriptions == null)
			return new ArrayList<PhotoDescription>();

		List<PhotoDescription> result = new ArrayList<PhotoDescription>();
		for (int i = 0; i < descriptions.length(); i++) {
			// The following cast will always succeed
			PhotoDescription curr = (PhotoDescription) descriptions.get(i);
			result.add(curr);
		}

		return result;
	}

	/**
	 * Returns a TileDescription that describes this tile.
	 *
	 * @return
	 * 		a {@link org.bodytrack.client.TileDescription TileDescription}
	 * 		that describes the level and offset for this tile
	 */
	public TileDescription getDescription() {
		return new TileDescription(getLevel(), getOffset());
	}
}
