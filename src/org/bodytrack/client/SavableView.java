package org.bodytrack.client;

import gwt.g2d.client.graphics.Color;

import java.util.ArrayList;
import java.util.List;

import org.bodytrack.client.ChannelManager.StringPair;

import com.google.gwt.core.client.JavaScriptObject;
import com.google.gwt.core.client.JsArray;
import com.google.gwt.core.client.JsArrayString;
import com.google.gwt.json.client.JSONArray;
import com.google.gwt.json.client.JSONNull;
import com.google.gwt.json.client.JSONNumber;
import com.google.gwt.json.client.JSONObject;
import com.google.gwt.json.client.JSONString;

/**
 * A class representing a view and the information that needs to be saved
 * or restored.
 *
 * <p>A <tt>SavableView</tt> is represented as a JSON dictionary, with four
 * required keys.  At the moment, all other keys are ignored, although future
 * implementations may add more keys and use those keys.  The first required
 * required field is name, which has a non-null, nonempty string as its
 * value.  Another required field is x_axes, which has a list as its value.
 * Each element of this list should be a dictionary, with two keys, min_time
 * and max_time.  Each of these values is a number representing seconds
 * since the epoch.  A third required field is y_axes, which has a list as
 * its value.  Each element of the list should be a dictionary, with two
 * required keys, min_val and max_val, and two optional keys, units and
 * label.  The min_val and max_val values should be numbers representing
 * the minimum and maximum bounds on the Y-axis, and the units and label
 * values should be strings.  The final required field in the top-level
 * dictionary is channels.  The value for this should be itself a
 * dictionary, with device names as keys.  Each device name points to a
 * nonempty dictionary, with channel names as keys.  Each channel name points
 * to a dictionary, with required keys x_axis, y_axis, and color, and optional
 * key type.  The x_axis key has a nonnegative integer value, which points
 * to the index in x_axes to use for the x-axis on that channel name.
 * Similarly, the y_axis key is a pointer into the y_axes array.  In both
 * cases, indices start at 0.  The color key is some HTML color string that
 * represents the color of the plotted channel.  See
 * {@link ColorUtils#buildColor(String)} for a description of supported
 * color formats.  The type key can have one of three string values at the
 * moment: plot, zeo, and photo.  If the value is plot (the default if the
 * type key is missing), the plot is assumed to be a standard data plot.  If
 * the value is zeo, the plot is assumed to be a Zeo plot.  If the value
 * is photo, the plot is assumed to be a photo plot.</p>
 */
// TODO: Implement and handle units
public final class SavableView extends JavaScriptObject {
	/* JavaScript overlay types always have protected empty constructors */
	protected SavableView() {}

	/**
	 * Returns a single SavableView, given a JSON string containing the data.
	 *
	 * <h2 style="color: red">WARNING:</h2>
	 *
	 * <p>Note that the JSON string is assumed to be trusted.  This method uses
	 * the JavaScript eval() function, <strong>which could allow arbitrary
	 * code to execute on a user's browser</strong> if this string was not
	 * completely generated by BodyTrack servers over a secure connection.
	 * This could allow an attacker to view all of a user's data, simply by
	 * filling in code to request all valid data tiles and then to send
	 * those tiles to the attacker's machine.  As such, data from insecure
	 * connections, and especially from cross-site requests, should not be
	 * passed in as the data parameter here.</p>
	 *
	 * @param json
	 * 		a JSON string containing data for a single tile
	 * @return
	 * 		a SavableView object with the same data as is found in json
	 */
	public static native SavableView buildView(String json) /*-{
		eval("var view = " + json);
		return view;
	}-*/;

	public static SavableView buildView(ChannelManager mgr, String name) {
		if (mgr == null)
			throw new NullPointerException(
				"Can't work with null set of channels");

		List<GraphAxis> xAxes = new ArrayList<GraphAxis>(mgr.getXAxes());
		List<GraphAxis> yAxes = new ArrayList<GraphAxis>(mgr.getYAxes());

		// Handle X-axes
		JSONArray xAxesJson = new JSONArray();
		for (int i = 0; i < xAxes.size(); i++) {
			JSONObject axis = new JSONObject();
			axis.put("min_time", new JSONNumber(xAxes.get(i).getMin()));
			axis.put("max_time", new JSONNumber(xAxes.get(i).getMax()));
			xAxesJson.set(i, axis);
		}

		// Handle Y-axes
		// Don't set units or label
		JSONArray yAxesJson = new JSONArray();
		for (int i = 0; i < yAxes.size(); i++) {
			JSONObject axis = new JSONObject();
			axis.put("min_val", new JSONNumber(yAxes.get(i).getMin()));
			axis.put("max_val", new JSONNumber(yAxes.get(i).getMax()));
			yAxesJson.set(i, axis);
		}

		// Handle the plots themselves
		JSONObject plotsJson = new JSONObject();

		// First, fill in the set of device names
		for (StringPair channel: mgr.getChannelNames())
			if (! plotsJson.containsKey(channel.getFirst()))
				plotsJson.put(channel.getFirst(), new JSONObject());

		// Now fill in the x_axis and y_axis fields for each device
		for (DataPlot plot: mgr.getDataPlots()) {
			String deviceName = plot.getDeviceName();
			String channelName = plot.getChannelName();

			JSONObject specificChannelInfo = new JSONObject();
			specificChannelInfo.put("x_axis",
				new JSONNumber(xAxes.indexOf(plot.getXAxis())));
			specificChannelInfo.put("y_axis",
				new JSONNumber(yAxes.indexOf(plot.getYAxis())));
			specificChannelInfo.put("color",
				new JSONString(plot.getColor().getColorCode()));
			specificChannelInfo.put("type",
				new JSONString(plot.getChartType().getName()));

			// We know this conversion is safe, since we just
			// created the object in the previous loop
			JSONObject deviceJson = plotsJson.get(deviceName).isObject();
			if (deviceJson == null) continue; // Should never happen
			deviceJson.put(channelName, specificChannelInfo);
		}

		JSONObject result = new JSONObject();
		result.put("name", name != null ? new JSONString(name)
										: JSONNull.getInstance());
			// The JSONString constructor throws an exception on
			// null, so we handle that gracefully with the line above

		result.put("x_axes", xAxesJson);
		result.put("y_axes", yAxesJson);
		result.put("channels", plotsJson);

		return buildView(result.toString());
	}

   /**
    * Converts this object into a {@link ChannelManager}.
    *
    * @param widget
    * 		the widget on which the new plots should be drawn
    * @return
    * 		a new <tt>ChannelManager</tt> that has plots for the
    * 		information contained in this <tt>SavableView</tt>, and
    * 		is attached to widget
    * @throws NullPointerException
    * 		if widget is <tt>null</tt>
    */
   public ChannelManager getDataPlots(GraphWidget widget) {
      if (widget == null) {
         throw new NullPointerException("Cannot draw on null widget");
      }

      final int axisMargin = Grapher2.getAxisMargin();
      final DataPlotFactory factory = DataPlotFactory.getInstance(widget);
      final ChannelManager result = new ChannelManager();

      // TODO: Put this in an actual div
      final GraphAxis[] xAxes = generateXAxes(null, axisMargin);

      for (final Channel channel : getChannels()) {
         // TODO: Put this in an actual div
         final DataPlot plot = factory.buildPlot(channel,
             xAxes[getXAxisIndex(channel)],
             generateYAxis(null, channel, axisMargin));

         // Set color of the plot, ensuring compatibility even when
         // the required color field isn't present
         final String colorName = getColor(channel);
         if (colorName != null) {
            final Color properColor = ColorUtils.buildColor(colorName);
            if (properColor != null) {
               plot.setColor(properColor);
            }
         }

         result.addChannel(plot);
      }

      return result;
   }

   private GraphAxis[] generateXAxes(String divName, int axisMargin) {
		GraphAxis[] xAxes = new GraphAxis[countXAxes()];

		for (int i = 0; i < xAxes.length; i++) {
			xAxes[i] = new TimeGraphAxis(divName,
				getMinTime(i),
				getMaxTime(i),
				Basis.xDownYRight,
				axisMargin * 7,
				true);
		}

		return xAxes;
	}

	private GraphAxis generateYAxis(final String divName,
			final Channel channel, final int axisMargin) {
      final int yAxisIndex = getYAxisIndex(channel);

      if (ChartType.PHOTO.equals(channel.getChartType()))
         return new PhotoGraphAxis(divName, axisMargin * 3);

      // Default unless we need a photo axis
      return new GraphAxis(divName,
            getMinValue(yAxisIndex),
            getMaxValue(yAxisIndex),
            Basis.xRightYUp,
            axisMargin * 3,
            false);
   }

	/**
	 * Returns the name for this view.
	 *
	 * @return
	 * 		the value of the name field in the native object
	 */
	public native String getName() /*-{
		return this.name;
	}-*/;

	/**
	 * Returns the number of X-axes for this object.
	 *
	 * @return
	 * 		the number of X-axes for this object
	 */
	public native int countXAxes() /*-{
		return this.x_axes.length;
	}-*/;

	/**
	 * Retrieves the min_time field from the X-axis at the specified
	 * index.
	 *
	 * <p>Performs no checks on the index used.</p>
	 *
	 * @param xAxisIndex
	 * 		the index of the axis for which to get the min time
	 * @return
	 * 		the min time of the X-axis at index xAxisIndex
	 */
	private native double getMinTimeUnchecked(int xAxisIndex) /*-{
		return this.x_axes[xAxisIndex].min_time;
	}-*/;

	/**
	 * Retrieves the minimum time from the X-axis at the specified index.
	 *
	 * @param xAxisIndex
	 * 		the index of the X-axis for which to get the minimum time
	 * @return
	 * 		the minimum time for the X-axis at index xAxisIndex
	 * @throws ArrayIndexOutOfBoundsException
	 * 		if xAxisIndex is negative or greater than or equal to
	 * 		the return value of {@link #countXAxes()}
	 */
	public double getMinTime(int xAxisIndex) {
		if (xAxisIndex < 0 || xAxisIndex >= countXAxes())
			throw new ArrayIndexOutOfBoundsException("Index " + xAxisIndex
				+ " cannot index into array of size " + countXAxes());

		return getMinTimeUnchecked(xAxisIndex);
	}

	/**
	 * Retrieves the max_time field from the X-axis at the specified
	 * index.
	 *
	 * <p>Performs no checks on the index used.</p>
	 *
	 * @param xAxisIndex
	 * 		the index of the axis for which to get the max time
	 * @return
	 * 		the max time of the X-axis at index xAxisIndex
	 */
	private native double getMaxTimeUnchecked(int xAxisIndex) /*-{
		return this.x_axes[xAxisIndex].max_time;
	}-*/;

	/**
	 * Retrieves the maximum time from the X-axis at the specified index.
	 *
	 * @param xAxisIndex
	 * 		the index of the X-axis for which to get the maximum time
	 * @return
	 * 		the maximum time for the X-axis at index xAxisIndex
	 * @throws ArrayIndexOutOfBoundsException
	 * 		if xAxisIndex is negative or greater than or equal to
	 * 		the return value of {@link #countXAxes()}
	 */
	public double getMaxTime(int xAxisIndex) {
		if (xAxisIndex < 0 || xAxisIndex >= countXAxes())
			throw new ArrayIndexOutOfBoundsException("Index " + xAxisIndex
				+ " cannot index into array of size " + countXAxes());

		return getMaxTimeUnchecked(xAxisIndex);
	}

	/**
	 * Returns the number of Y-axes for this object.
	 *
	 * @return
	 * 		the number of Y-axes for this object
	 */
	public native int countYAxes() /*-{
		return this.y_axes.length;
	}-*/;

	/**
	 * Retrieves the min_val field from the Y-axis at the specified
	 * index.
	 *
	 * <p>Performs no checks on the index used.</p>
	 *
	 * @param yAxisIndex
	 * 		the index of the axis for which to get the min value
	 * @return
	 * 		the min value of the Y-axis at index yAxisIndex
	 */
	private native double getMinValueUnchecked(int yAxisIndex) /*-{
		return this.y_axes[yAxisIndex].min_val;
	}-*/;

	/**
	 * Retrieves the minimum value from the Y-axis at the specified index.
	 *
	 * @param yAxisIndex
	 * 		the index of the Y-axis for which to get the minimum value
	 * @return
	 * 		the minimum time for the Y-axis at index yAxisIndex
	 * @throws ArrayIndexOutOfBoundsException
	 * 		if yAxisIndex is negative or greater than or equal to
	 * 		the return value of {@link #countYAxes()}
	 */
	public double getMinValue(int yAxisIndex) {
		if (yAxisIndex < 0 || yAxisIndex >= countYAxes())
			throw new ArrayIndexOutOfBoundsException("Index " + yAxisIndex
				+ " cannot index into array of size " + countYAxes());

		return getMinValueUnchecked(yAxisIndex);
	}

	/**
	 * Retrieves the max_val field from the Y-axis at the specified
	 * index.
	 *
	 * <p>Performs no checks on the index used.</p>
	 *
	 * @param yAxisIndex
	 * 		the index of the axis for which to get the max value
	 * @return
	 * 		the max value of the Y-axis at index yAxisIndex
	 */
	private native double getMaxValueUnchecked(int yAxisIndex) /*-{
		return this.y_axes[yAxisIndex].max_val;
	}-*/;

	/**
	 * Retrieves the maximum value from the Y-axis at the specified index.
	 *
	 * @param yAxisIndex
	 * 		the index of the Y-axis for which to get the maximum value
	 * @return
	 * 		the maximum time for the Y-axis at index yAxisIndex
	 * @throws ArrayIndexOutOfBoundsException
	 * 		if yAxisIndex is negative or greater than or equal to
	 * 		the return value of {@link #countYAxes()}
	 */
	public double getMaxValue(int yAxisIndex) {
		if (yAxisIndex < 0 || yAxisIndex >= countYAxes())
			throw new ArrayIndexOutOfBoundsException("Index " + yAxisIndex
				+ " cannot index into array of size " + countYAxes());

		return getMaxValueUnchecked(yAxisIndex);
	}

	/**
	 * Generates the list of channels in this <tt>SavableView</tt>.
	 *
	 * <p>Returns an array of arrays, where the outer array is the list of
	 * channels, and each inner array represents a channel, with the first
	 * element representing the device and the second representing the
	 * channel name.</p>
	 *
	 * @return
	 * 		the list of channel names in this <tt>SavableView</tt>
	 */
	private native JsArray<JsArrayString> getChannelNames() /*-{
		var channelNames = [];
		// The calls to hasOwnProperty filters out keys that come because
		// of some function being grafted onto the JavaScript core
		for (var device in this.channels) {
			if (this.channels.hasOwnProperty(device)) {
				var channeldict = this.channels[device];
				for (var chan in channeldict) {
					if (channeldict.hasOwnProperty(chan)) {
						channelNames.push([device, chan]);
					}
				}
			}
		}
		return channelNames;
	}-*/;

	/**
	 * Generates a {@link List} of {@link Channel channels} stored in this view.
	 *
	 * @return
	 * 		a {@link List} of the {@link Channel channels} stored in this view
	 */
	public List<Channel> getChannels() {
		final List<Channel> channels = new ArrayList<Channel>();

		final JsArray<JsArrayString> channelNames = getChannelNames();

		for (int i = 0; i < channelNames.length(); i++) {
			final JsArrayString rawChannel = channelNames.get(i);
			// Silently ignore errors.  Not ideal, but probably the best
			// for the user in the face of such a rare event
			if (rawChannel.length() != 2)
				continue;

			final String device = rawChannel.get(0);
			final String channel = rawChannel.get(1);
         final String type = getType(device, channel);
			channels.add(new Channel(device, channel, type));
		}

		return channels;
	}

	/**
	 * Returns <tt>true</tt> if and only if this contains the specified
	 * channel.
	 *
	 * @param deviceName
	 * 		the device name we want to check
	 * @param channelName
	 * 		the channel name we want to check
	 * @return
	 * 		<tt>true</tt> if and only if this contains the specified channel.
	 * 		If deviceName or channelName is <tt>null</tt>, automatically
	 * 		returns <tt>false</tt>
	 */
	public native boolean hasChannel(String deviceName,
			String channelName) /*-{
		return (!! deviceName) && (!! channelName) && (!! this.channels) &&
			(!! this.channels[deviceName]) &&
			(!! this.channels[deviceName][channelName]);
	}-*/;

	/**
	 * Retrieves the x_axis field from the specified channel.
	 *
	 * <p>Performs no checks on the key and value.</p>
	 *
	 * @param deviceName
	 * 		the device name for which we want the X-axis index
	 * @param channelName
	 * 		the channel name for which we want the X-axis index
	 * @return
	 * 		the X-axis index for the specified channel
	 */
	private native int getXAxisIndexUnchecked(String deviceName,
			String channelName) /*-{
		return this.channels[deviceName][channelName].x_axis;
	}-*/;

	/**
	 * Returns the X-axis index for the specified channel.
	 *
	 * @param deviceName
	 * 		the device name for which we want the X-axis index
	 * @param channelName
	 * 		the channel name for which we want the X-axis index
	 * @return
	 * 		the X-axis index for the specified channel
	 * @throws IllegalArgumentException
	 * 		if the specified channel is not an element of the
	 * 		return values of {@link #getChannels()}
	 */
	public int getXAxisIndex(final Channel channel) {
      if (! hasChannel(channel.getDeviceName(), channel.getChannelName()))
			throw new IllegalArgumentException(
				"Cannot find index for channel that does not exist");

		return getXAxisIndexUnchecked(channel.getDeviceName(), channel.getChannelName());
	}

	/**
	 * Retrieves the y_axis field from the specified channel.
	 *
	 * <p>Performs no checks on the key and value.</p>
	 *
	 * @param deviceName
	 * 		the device name for which we want the Y-axis index
	 * @param channelName
	 * 		the channel name for which we want the Y-axis index
	 * @return
	 * 		the Y-axis index for the specified channel
	 */
	private native int getYAxisIndexUnchecked(String deviceName,
			String channelName) /*-{
		return this.channels[deviceName][channelName].y_axis;
	}-*/;

	/**
	 * Returns the Y-axis index for the specified channel.
	 *
	 * @param deviceName
	 * 		the device name for which we want the Y-axis index
	 * @param channelName
	 * 		the channel name for which we want the Y-axis index
	 * @return
	 * 		the Y-axis index for the specified channel
	 * @throws IllegalArgumentException
	 * 		if the specified channel is not an element of the
	 * 		return values of {@link #getChannels()}
	 */
	public int getYAxisIndex(final Channel channel) {
		if (! hasChannel(channel.getDeviceName(), channel.getChannelName()))
			throw new IllegalArgumentException(
				"Cannot find index for channel that does not exist");

		return getYAxisIndexUnchecked(channel.getDeviceName(), channel.getChannelName());
	}

	/**
	 * Retrieves the color field from the specified channel.
	 *
	 * <p>Performs no checks on the key and value.</p>
	 *
	 * @param deviceName
	 * 		the device name for which we want the color string
	 * @param channelName
	 * 		the channel name for which we want the color string
	 * @return
	 * 		the color string for the specified channel
	 */
	private native String getColorUnchecked(String deviceName,
			String channelName) /*-{
		return this.channels[deviceName][channelName].color;
	}-*/;

	/**
	 * Returns the color string for the specified channel.
	 *
	 * @param channel
	 * 		the channel for which we want the color string
	 * @return
	 * 		the color string for the specified channel
	 * @throws IllegalArgumentException
	 * 		if the specified channel is not an element of the
	 * 		return values of {@link #getChannels()}
	 */
	public String getColor(final Channel channel) {
		if (! hasChannel(channel.getDeviceName(), channel.getChannelName()))
			throw new IllegalArgumentException(
				"Cannot find color for channel that does not exist");

		return getColorUnchecked(channel.getDeviceName(), channel.getChannelName());
	}

	/**
	 * Retrieves the type field from the specified channel.
	 *
	 * <p>Performs no checks on the key and value.</p>
	 *
	 * @param deviceName
	 * 		the device name for which we want the channel type
	 * @param channelName
	 * 		the channel name for which we want the channel type
	 * @return
	 * 		the type name for the specified channel
	 */
	private native String getTypeUnchecked(String deviceName,
			String channelName) /*-{
		// Since this is an optional field, we return null if the field
		// is not present
		return this.channels[deviceName][channelName].type || null;
	}-*/;

	/**
	 * Returns the plot type for the specified channel.
	 *
	 * @param deviceName
	 * 		the device name for which we want the plot type
	 * @param channelName
	 * 		the channel name for which we want the plot type
	 * @return
	 * 		the type name for the specified channel, or <tt>null</tt>
	 * 		if the type name parameter is not present (since the type
	 * 		name is an optional parameter)
	 * @throws IllegalArgumentException
	 * 		if the specified channel is not an element of the
	 * 		return values of {@link #getChannels()}
	 */
	public String getType(String deviceName, String channelName) {
		if (! hasChannel(deviceName, channelName))
			throw new IllegalArgumentException(
				"Cannot find plot type for channel that does not exist");

		return getTypeUnchecked(deviceName, channelName);
	}
}
