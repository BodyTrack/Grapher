package org.bodytrack.client;

import java.util.ArrayList;
import java.util.List;

import com.google.gwt.core.client.JavaScriptObject;
import com.google.gwt.core.client.JsArray;
import com.google.gwt.core.client.JsArrayNumber;
import com.google.gwt.core.client.JsArrayString;

public final class PlottablePointTile extends JavaScriptObject {
	// Overlay types always have protected, zero-arg constructors
	// with empty bodies
	protected PlottablePointTile() { }

	/**
	 * Returns a single GrapherTile, given a JSON string containing the data.
	 *
	 * <h2 style="color: red">WARNING:</h2>
	 *
	 * <p>Note that the JSON string is assumed to be trusted.  This method uses
	 * the JavaScript eval() function, <strong>which could allow arbitrary
	 * code to execute on a user's browser</strong> if this string was not
	 * completely generated by BodyTrack servers over a secure connection.
	 * This could allow an attacker to view all of a user's data, simply by
	 * filling in code to request all valid data tiles and then to send
	 * those tiles to the attacker's machine.  As such, data from insecure
	 * connections, and especially from cross-site requests, should not be
	 * passed in as the data parameter here.</p>
	 *
	 * @param json
	 * 		a JSON string containing data for a single tile
	 * @return
	 * 		a GrapherTile object with the same data as is found in json
	 */
	public static native PlottablePointTile buildTile(String json) /*-{
		eval("var tile = " + json);
		return tile;
	}-*/;

	/**
	 * Returns the level of resolution at which this tile operates.
	 *
	 * <p>Note that level 0 corresponds to data points 1 second apart,
	 * and that levels scale in powers of 2.  For instance, level 1
	 * corresponds to data points 2 seconds apart, level 2 corresponds
	 * to data points 4 seconds apart, etc.  Levels can be positive or
	 * negative.</p>
	 *
	 * @return
	 * 		the level of resolution at which this tile operates
	 */
	public native int getLevel() /*-{
		return this.level;
	}-*/;

	/**
	 * Returns the offset from the epoch at which this tile is found.
	 *
	 * <p>If we consider a very larger array of tiles, each one at the same
	 * level as this one, and tile 0 beginning on midnight of 1/1/1970,
	 * the offset is the index in this array at which we can find this
	 * tile.</p>
	 *
	 * @return
	 * 		the offset value for this tile
	 */
	public native int getOffset() /*-{
		return this.offset;
	}-*/;

	/**
	 * Returns the list of field names for this tile.
	 *
	 * @return
	 * 		the list of field names for this tile
	 */
	public native JsArrayString getFields() /*-{
		return this.fields;
	}-*/;

	/**
	 * Returns the data stored in this tile.
	 *
	 * @return
	 * 		the data stored in this tile, as a two-dimensional array of
	 * 		double-precision values
	 */
	public native JsArray<JsArrayNumber> getData() /*-{
		return this.data;
	}-*/;

	/**
	 * Returns the value of the optional sample_width parameter in a tile.
	 *
	 * <p>Currently, this is a field only used by the Zeo data.</p>
	 *
	 * @return
	 * 		the value of the sample_width field for this tile, or a
	 * 		negative number if such a field is not present
	 */
	public native double getSampleWidth() /*-{
		if (! this.sample_width)
			return -1.0;

		return this.sample_width;
	}-*/;

	/**
	 * Returns the data points that should be graphed for this GrapherTile.
	 *
	 * <p>Note that this works if and only if this GrapherTile represents
	 * a series of data points, not a photo description.</p>
	 *
	 * @return
	 * 		a {@link java.util.List List} of
	 * 		{@link org.bodytrack.client.PlottablePoint PlottablePoint}
	 * 		objects that represent the data in this PlottablePointTile, or
	 * 		<tt>null</tt> if the required data does not seem to be
	 * 		available (i.e. the field names &quot;time&quot; and
	 * 		&quot;mean&quot; are not elements of the array returned
	 * 		by {@link #getFields() getFields()})
	 */
	public List<PlottablePoint> getDataPoints() {
		int timeIndex = -1;
		int meanIndex = -1;

		JsArrayString fieldNames = getFields();

		for (int i = 0; i < fieldNames.length(); i++) {
			if (fieldNames.get(i).equalsIgnoreCase("time"))
				timeIndex = i;
			else if (fieldNames.get(i).equalsIgnoreCase("mean"))
				meanIndex = i;
		}

		if (timeIndex < 0 || meanIndex < 0)
			return null;

		List<PlottablePoint> result = new ArrayList<PlottablePoint>();
		JsArray<JsArrayNumber> dataPoints = getData();

		for (int i = 0; i < dataPoints.length(); i++) {
			JsArrayNumber dataPoint = dataPoints.get(i);

			double time = dataPoint.get(timeIndex);
			double mean = dataPoint.get(meanIndex);

			result.add(new PlottablePoint(time, mean));
		}

		return result;
	}

	/**
	 * Returns a TileDescription that describes this tile.
	 *
	 * @return
	 * 		a {@link org.bodytrack.client.TileDescription TileDescription}
	 * 		that describes the level and offset for this tile
	 */
	public TileDescription getDescription() {
		return new TileDescription(getLevel(), getOffset());
	}
}
