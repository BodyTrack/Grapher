package org.bodytrack.client;

import com.google.gwt.core.client.JavaScriptObject;
import com.google.gwt.core.client.JsArray;
import com.google.gwt.core.client.JsArrayMixed;
import com.google.gwt.core.client.JsArrayString;

import java.util.ArrayList;
import java.util.List;

/**
 * Representation of a tile of points that can be plotted in
 * two dimensions.
 *
 * <p>This is a JavaScript overlay type for a tile.  This tile is
 * assumed to have dictionary entries called &quot;level&quot;,
 * &quot;offset&quot;, &quot;fields&quot;, and &quot;data&quot;.
 * It may optionally have a field called &quot;sample_width&quot;,
 * which applies for Zeo data.</p>
 */
public final class PlottablePointTile extends JavaScriptObject {
   // Overlay types always have protected, zero-arg constructors
   // with empty bodies
   protected PlottablePointTile() {
   }

   /**
    * Returns a single PlottablePointTile, given a JSON string containing
    * the data.
    *
    * <h2 style="color: red">WARNING:</h2>
    *
    * <p>Note that the JSON string is assumed to be trusted.  This method uses
    * the JavaScript eval() function, <strong>which could allow arbitrary
    * code to execute on a user's browser</strong> if this string was not
    * completely generated by BodyTrack servers over a secure connection.
    * This could allow an attacker to view all of a user's data, simply by
    * filling in code to request all valid data tiles and then to send
    * those tiles to the attacker's machine.  As such, data from insecure
    * connections, and especially from cross-site requests, should not be
    * passed in as the data parameter here.</p>
    *
    * @param json
    * 		a JSON string containing data for a single tile
    * @return
    * 		a PlottablePointTile object with the same data as is found
    * 		in json
    */
   public static native PlottablePointTile buildTile(String json) /*-{
      return JSON.parse(json);
   }-*/;

   /**
    * Returns the level of resolution at which this tile operates.
    *
    * <p>Note that level 0 corresponds to data points 1 second apart,
    * and that levels scale in powers of 2.  For instance, level 1
    * corresponds to data points 2 seconds apart, level 2 corresponds
    * to data points 4 seconds apart, etc.  Levels can be positive or
    * negative.</p>
    *
    * @return
    * 		the level of resolution at which this tile operates
    */
   public native int getLevel() /*-{
      return this.level;
   }-*/;

   /**
    * Returns the offset from the epoch at which this tile is found.
    *
    * <p>If we consider a very larger array of tiles, each one at the same
    * level as this one, and tile 0 beginning on midnight of 1/1/1970,
    * the offset is the index in this array at which we can find this
    * tile.</p>
    *
    * @return
    * 		the offset value for this tile
    */
   public native int getOffset() /*-{
      return this.offset;
   }-*/;

   /**
    * Returns the list of field names for this tile.
    *
    * @return
    * 		the list of field names for this tile
    */
   public native JsArrayString getFields() /*-{
      return this.fields;
   }-*/;

   /**
    * Returns the data stored in this tile.
    *
    * @return
    * 		the data stored in this tile, as a two-dimensional array of
    * 		double-precision values
    */
   public native JsArray<JsArrayMixed> getData() /*-{
      return this.data;
   }-*/;

   /**
    * Returns the value of the optional sample_width parameter in a tile.
    *
    * @return
    * 		the value of the sample_width field for this tile, or a
    * 		negative number if such a field is not present
    */
   public native double getSampleWidth() /*-{
      if (! this.sample_width)
         return -1.0;

      return this.sample_width;
   }-*/;

   /**
    * Returns the data points that should be graphed for this GrapherTile.
    *
    * <p>Note that this works if and only if this GrapherTile represents
    * a series of data points, not a photo description.</p>
    *
    * @return
    * 		a {@link List} of {@link PlottablePoint}
    * 		objects that represent the data in this PlottablePointTile, or
    * 		<tt>null</tt> if the required data does not seem to be
    * 		available (i.e. the field names &quot;time&quot; and
    * 		&quot;mean&quot; are not elements of the array returned
    * 		by {@link #getFields() getFields()})
    */
   public List<PlottablePoint> getDataPoints() {
      int timeIndex = -1;
      int meanIndex = -1;
      int commentIndex = -1;
      int countIndex = -1;

      final JsArrayString fieldNames = getFields();
      
      List<String> sideChannelNames = new ArrayList<String>();
      List<Integer> sideChannelIndices = new ArrayList<Integer>();

      for (int i = 0; i < fieldNames.length(); i++) {
         if ("time".equalsIgnoreCase(fieldNames.get(i))) {
            timeIndex = i;
         }
         else if ("mean".equalsIgnoreCase(fieldNames.get(i))) {
            meanIndex = i;
         }
         else if ("comment".equalsIgnoreCase(fieldNames.get(i))) {
            commentIndex = i;
         }
         else if ("count".equalsIgnoreCase(fieldNames.get(i))){
        	 countIndex = i;
         }
         else if ("stddev".equalsIgnoreCase(fieldNames.get(i))){
        	 //we don't do anything with standard deviation yet, but it should be hidden from the sidechannel list
         }
         else{
        	 sideChannelNames.add(fieldNames.get(i));
        	 sideChannelIndices.add(i);
         }
      }

      if (timeIndex < 0 || meanIndex < 0) {
         return null;
      }

      final List<PlottablePoint> result = new ArrayList<PlottablePoint>();
      final JsArray<JsArrayMixed> dataPoints = getData();

      for (int i = 0; i < dataPoints.length(); i++) {
         final JsArrayMixed dataPoint = dataPoints.get(i);

         final double time = dataPoint.getNumber(timeIndex);
         final double mean = dataPoint.getNumber(meanIndex);
         final int count = (int) dataPoint.getNumber(countIndex);
         String comment = null;
         if (commentIndex >= 0) {
            final String commentTemp = dataPoint.getString(commentIndex);
            if (commentTemp != null && !"null".equalsIgnoreCase(commentTemp)) {
               comment = commentTemp;
            }
         }
         
         List<Object> sideChannelData = new ArrayList<Object>();
         
         for (int j = 0, lj = sideChannelNames.size(); j < lj; j++){
        	 sideChannelData.add(dataPoint.getObject(sideChannelIndices.get(j)));        	 
         }

         result.add(new PlottablePoint(time, mean, comment, count,sideChannelNames.toArray(new String[]{}),sideChannelData.toArray()));
      }

      return result;
   }

   /**
    * Returns a TileDescription that describes this tile.
    *
    * @return
    * 		a {@link TileDescription} that describes the level and offset for this tile
    */
   public TileDescription getDescription() {
      return new TileDescription(getLevel(), getOffset());
   }
}
