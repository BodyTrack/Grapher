package org.bodytrack.client;

import com.google.gwt.core.client.JavaScriptObject;
import com.google.gwt.core.client.JsArray;
import com.google.gwt.core.client.JsArrayMixed;
import com.google.gwt.core.client.JsArrayString;

import java.util.ArrayList;
import java.util.List;

/**
 * Representation of a tile of points that can be plotted in
 * two dimensions.
 *
 * <p>This is a JavaScript overlay type for a tile.  This tile is
 * assumed to have dictionary entries called &quot;level&quot;,
 * &quot;offset&quot;, &quot;fields&quot;, and &quot;data&quot;.
 * It may optionally have a field called &quot;sample_width&quot;,
 * which applies for Zeo data.</p>
 */
public final class PlottablePointTile extends JavaScriptObject {
   // Overlay types always have protected, zero-arg constructors
   // with empty bodies
   protected PlottablePointTile() {
   }

   /**
    * Returns a single PlottablePointTile, given a JSON string containing
    * the data.
    *
    * <h2 style="color: red">WARNING:</h2>
    *
    * <p>Note that the JSON string is assumed to be trusted.  This method uses
    * the JavaScript eval() function, <strong>which could allow arbitrary
    * code to execute on a user's browser</strong> if this string was not
    * completely generated by BodyTrack servers over a secure connection.
    * This could allow an attacker to view all of a user's data, simply by
    * filling in code to request all valid data tiles and then to send
    * those tiles to the attacker's machine.  As such, data from insecure
    * connections, and especially from cross-site requests, should not be
    * passed in as the data parameter here.</p>
    *
    * @param json
    * 		a JSON string containing data for a single tile
    * @return
    * 		a PlottablePointTile object with the same data as is found
    * 		in json
    */
   public static native PlottablePointTile buildTile(String json) /*-{
      eval("var tile = " + json);
      return tile;
   }-*/;


   public native int getLevel() /*-{
      return this.level;
   }-*/;


   public long getOffset() {
      return (long)getRawOffset();
   }

   private native double getRawOffset() /*-{
      return this.offset;
   }-*/;

   /**
    * Returns the list of field names for this tile.
    *
    * @return
    * 		the list of field names for this tile
    */
   public native JsArrayString getFields() /*-{
      return this.fields;
   }-*/;

   /**
    * Returns the data stored in this tile.
    *
    * @return
    * 		the data stored in this tile, as a two-dimensional array of
    * 		double-precision values
    */
   public native JsArray<JsArrayMixed> getData() /*-{
      return this.data;
   }-*/;

   /**
    * Returns the value of the optional sample_width parameter in a tile.
    *
    * <p>Currently, this is a field only used by the Zeo data.</p>
    *
    * @return
    * 		the value of the sample_width field for this tile, or a
    * 		negative number if such a field is not present
    */
   public native double getSampleWidth() /*-{
      if (! this.sample_width)
         return -1.0;

      return this.sample_width;
   }-*/;

   /**
    * Returns the data points that should be graphed for this GrapherTile.
    *
    * <p>Note that this works if and only if this GrapherTile represents
    * a series of data points, not a photo description.</p>
    *
    * @return
    * 		a {@link List} of {@link PlottablePoint}
    * 		objects that represent the data in this PlottablePointTile, or
    * 		<tt>null</tt> if the required data does not seem to be
    * 		available (i.e. the field names &quot;time&quot; and
    * 		&quot;mean&quot; are not elements of the array returned
    * 		by {@link #getFields() getFields()})
    */
   public List<PlottablePoint> getDataPoints() {
      int timeIndex = -1;
      int meanIndex = -1;
      int commentIndex = -1;

      final JsArrayString fieldNames = getFields();

      for (int i = 0; i < fieldNames.length(); i++) {
         if ("time".equalsIgnoreCase(fieldNames.get(i))) {
            timeIndex = i;
         }
         else if ("mean".equalsIgnoreCase(fieldNames.get(i))) {
            meanIndex = i;
         }
         else if ("comment".equalsIgnoreCase(fieldNames.get(i))) {
            commentIndex = i;
         }
      }

      if (timeIndex < 0 || meanIndex < 0) {
         return null;
      }

      final List<PlottablePoint> result = new ArrayList<PlottablePoint>();
      final JsArray<JsArrayMixed> dataPoints = getData();

      for (int i = 0; i < dataPoints.length(); i++) {
         final JsArrayMixed dataPoint = dataPoints.get(i);

         final double time = dataPoint.getNumber(timeIndex);
         final double mean = dataPoint.getNumber(meanIndex);
         String comment = null;
         if (commentIndex >= 0) {
            final String commentTemp = dataPoint.getString(commentIndex);
            if (commentTemp != null && !"null".equalsIgnoreCase(commentTemp)) {
               comment = commentTemp;
            }
         }

         result.add(new PlottablePoint(time, mean, comment));
      }

      return result;
   }

   /**
    * Returns a TileDescription that describes this tile.
    *
    * @return
    * 		a {@link TileDescription} that describes the level and offset for this tile
    */
   public TileDescription getDescription() {
      return new TileDescription(getLevel(), getOffset());
   }
}
